<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Support\Str;

class Question extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'domain_id',
        'content',
    ];

    /**
     * Relation avec l'utilisateur qui a pos√© la question
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relation avec le domaine de la question
     */
    public function domain(): BelongsTo
    {
        return $this->belongsTo(Domain::class);
    }

    /**
     * Relation avec les r√©ponses des IA
     */
    public function iaResponses(): HasMany
    {
        return $this->hasMany(IaResponse::class);
    }

    /**
     * Relation avec l'√©valuation (une seule par question)
     */
    public function evaluation(): HasOne
    {
        return $this->hasOne(Evaluation::class);
    }

    /**
     * V√©rifie si la question appartient au domaine "Programmation"
     * LOGIQUE CORRIG√âE : PRIORIT√â ABSOLUE AU DOMAINE CHOISI
     */
    public function isProgrammingQuestion(): bool
    {
        if (!$this->domain) {
            return false;
        }

        // üéØ PRIORIT√â 1 : V√©rification STRICTE par nom de domaine
        $domainName = strtolower($this->domain->name);
        $domainSlug = strtolower($this->domain->slug ?? '');

        // Mots-cl√©s EXPLICITES pour programmation
        $programmingDomains = [
            'programmation', 'programming', 'code', 'coding',
            'd√©veloppement', 'development', 'informatique',
            'web', 'software', 'logiciel', 'application'
        ];

        // Si le domaine contient ces mots, c'est D√âFINITIVEMENT de la programmation
        foreach ($programmingDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question PROGRAMMATION d√©tect√©e par domaine explicite', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'keyword_matched' => $keyword
                ]);
                return true;
            }
        }

        // üéØ PRIORIT√â 2 : Exclusion explicite des domaines math√©matiques
        $mathDomains = [
            'math√©matiques', 'mathematics', 'math', 'maths',
            'logique', 'logic', 'calcul', 'calculation',
            'alg√®bre', 'algebra', 'g√©om√©trie', 'geometry'
        ];

        foreach ($mathDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question NON-PROGRAMMATION : domaine math√©matique d√©tect√©', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'math_keyword' => $keyword
                ]);
                return false;
            }
        }

        // üéØ PRIORIT√â 3 : Analyse du contenu seulement si le domaine est ambigu
        $hasProgrammingContent = $this->hasProgrammingContent($this->content);

        if ($hasProgrammingContent) {
            \Log::info('Question PROGRAMMATION d√©tect√©e par contenu', [
                'question_id' => $this->id,
                'domain_name' => $this->domain->name,
                'content_preview' => Str::limit($this->content, 100)
            ]);
        }

        return $hasProgrammingContent;
    }

    /**
     * V√©rifie si la question appartient au domaine "Math√©matiques"
     * LOGIQUE CORRIG√âE : PRIORIT√â ABSOLUE AU DOMAINE CHOISI
     */
    public function isMathematicalQuestion(): bool
    {
        if (!$this->domain) {
            return false;
        }

        // üéØ PRIORIT√â 1 : V√©rification STRICTE par nom de domaine
        $domainName = strtolower($this->domain->name);
        $domainSlug = strtolower($this->domain->slug ?? '');

        // Mots-cl√©s EXPLICITES pour math√©matiques
        $mathDomains = [
            'math√©matiques', 'mathematics', 'math', 'maths',
            'logique', 'logic', 'calcul', 'calculation',
            'alg√®bre', 'algebra', 'g√©om√©trie', 'geometry',
            'statistique', 'statistics', 'probabilit√©', 'probability'
        ];

        // Si le domaine contient ces mots, c'est D√âFINITIVEMENT des math√©matiques
        foreach ($mathDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question MATH√âMATIQUES d√©tect√©e par domaine explicite', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'keyword_matched' => $keyword
                ]);
                return true;
            }
        }

        // üéØ PRIORIT√â 2 : Exclusion explicite des domaines de programmation
        $programmingDomains = [
            'programmation', 'programming', 'code', 'coding',
            'd√©veloppement', 'development', 'informatique',
            'web', 'software', 'logiciel', 'application'
        ];

        foreach ($programmingDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question NON-MATH√âMATIQUES : domaine programmation d√©tect√©', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'programming_keyword' => $keyword
                ]);
                return false;
            }
        }

        // üéØ PRIORIT√â 3 : Analyse du contenu seulement si le domaine est ambigu
        $hasMathContent = $this->hasMathematicalContent($this->content);

        if ($hasMathContent) {
            \Log::info('Question MATH√âMATIQUES d√©tect√©e par contenu', [
                'question_id' => $this->id,
                'domain_name' => $this->domain->name,
                'content_preview' => Str::limit($this->content, 100)
            ]);
        }

        return $hasMathContent;
    }


    public function isTranslationQuestion(): bool
    {
        if (!$this->domain) {
            return false;
        }

        // üéØ PRIORIT√â 1 : V√©rification STRICTE par nom de domaine
        $domainName = strtolower($this->domain->name);
        $domainSlug = strtolower($this->domain->slug ?? '');

        // Mots-cl√©s EXPLICITES pour traduction
        $translationDomains = [
            'traduction', 'translation', 'translate', 'traduire',
            'langues', 'languages', 'linguistique', 'linguistics'
        ];

        // Si le domaine contient ces mots, c'est D√âFINITIVEMENT de la traduction
        foreach ($translationDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question TRADUCTION d√©tect√©e par domaine explicite', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'keyword_matched' => $keyword
                ]);
                return true;
            }
        }

        // üéØ PRIORIT√â 2 : Exclusion explicite des domaines programmation/math√©matiques
        $nonTranslationDomains = [
            'programmation', 'programming', 'code', 'd√©veloppement',
            'math√©matiques', 'mathematics', 'math', 'logique', 'calcul'
        ];

        foreach ($nonTranslationDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                \Log::info('Question NON-TRADUCTION : domaine non-traduction d√©tect√©', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'non_translation_keyword' => $keyword
                ]);
                return false;
            }
        }

        // üéØ PRIORIT√â 3 : Analyse du contenu seulement si le domaine est ambigu
        $hasTranslationContent = $this->hasTranslationContent($this->content);

        if ($hasTranslationContent) {
            \Log::info('Question TRADUCTION d√©tect√©e par contenu', [
                'question_id' => $this->id,
                'domain_name' => $this->domain->name,
                'content_preview' => Str::limit($this->content, 100)
            ]);
        }

        return $hasTranslationContent;
    }

    /**
     * V√©rifie si une question est √©valuable (programmation OU math√©matiques)
     * AVEC LOGIQUE EXCLUSIVE
     */
    public function isEvaluableQuestion(): bool
    {
        $isProgramming = $this->isProgrammingQuestion();
        $isMathematical = $this->isMathematicalQuestion();
        $isTranslation = $this->isTranslationQuestion(); // üåê NOUVEAU

        // üö® CORRECTION : Une question ne peut √™tre qu'un seul type √† la fois
        if (($isProgramming && $isMathematical) ||
            ($isProgramming && $isTranslation) ||
            ($isMathematical && $isTranslation)) {
            \Log::warning('CONFLIT D√âTECT√â : Question d√©tect√©e comme plusieurs types', [
                'question_id' => $this->id,
                'domain_name' => $this->domain->name,
                'is_programming' => $isProgramming,
                'is_mathematical' => $isMathematical,
                'is_translation' => $isTranslation,
                'resolution' => 'Priorit√© donn√©e selon l\'ordre de v√©rification'
            ]);

            // En cas de conflit, priorit√© : traduction > programmation > math√©matiques
            if ($isTranslation) {
                $isProgramming = false;
                $isMathematical = false;
            } elseif ($isProgramming) {
                $isMathematical = false;
            }
        }

        $isEvaluable = $isProgramming || $isMathematical || $isTranslation;

        \Log::info('V√©rification √©valuabilit√© AVEC TRADUCTION', [
            'question_id' => $this->id,
            'domain_name' => $this->domain->name,
            'is_programming' => $isProgramming,
            'is_mathematical' => $isMathematical,
            'is_translation' => $isTranslation, // üåê NOUVEAU
            'is_evaluable' => $isEvaluable
        ]);

        return $isEvaluable;
    }

    /**
     * D√©termine le type d'√©valuation n√©cessaire
     * LOGIQUE EXCLUSIVE CORRIG√âE
     */
    public function getEvaluationType(): string
    {
        // V√©rifier dans l'ordre de priorit√© : traduction > programmation > math√©matiques
        if ($this->isTranslationQuestion()) {
            // Double-v√©rification pour √©viter les conflits
            if ($this->isProgrammingQuestion() || $this->isMathematicalQuestion()) {
                \Log::warning('CONFLIT dans getEvaluationType avec traduction', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'resolution' => 'Priorit√© donn√©e √† la traduction'
                ]);
            }
            return 'translation'; // üåê NOUVEAU

        } elseif ($this->isProgrammingQuestion()) {
            // Double-v√©rification pour √©viter les conflits
            if ($this->isMathematicalQuestion()) {
                \Log::warning('CONFLIT dans getEvaluationType', [
                    'question_id' => $this->id,
                    'domain_name' => $this->domain->name,
                    'resolution' => 'Priorit√© donn√©e √† la programmation car d√©tect√©e en premier'
                ]);
            }
            return 'programming';

        } elseif ($this->isMathematicalQuestion()) {
            return 'mathematics';

        } else {
            return 'none';
        }
    }
    /**
     * M√âTHODE CORRIG√âE : D√©tection sp√©cifique du contenu de programmation
     * Plus stricte pour √©viter les faux positifs
     */
    protected function hasProgrammingContent(string $content): bool
    {
        $programmingKeywords = [
            // Langages de programmation EXPLICITES
            'python', 'javascript', 'java', 'php', 'c++', 'c#', 'ruby', 'go', 'rust',
            'html', 'css', 'sql', 'bash', 'shell', 'kotlin', 'swift', 'typescript',

            // Concepts de programmation SP√âCIFIQUES
            'classe', 'class', 'objet', 'object', 'm√©thode', 'method',
            'fonction', 'function', 'variable', 'array', 'tableau',
            'boucle', 'loop', 'condition', 'algorithme', 'algorithm',
            'r√©cursion', 'recursion', 'iteration',

            // Outils et frameworks EXPLICITES
            'framework', 'api', 'database', 'serveur', 'server',
            'git', 'github', 'docker', 'kubernetes', 'laravel', 'react', 'vue',

            // Syntaxe de code SP√âCIFIQUE
            'def ', 'function ', 'class ', 'import ', 'require',
            'console.log', 'print(', 'echo ', 'return', 'var ', 'let ', 'const ',

            // Concepts web et d√©veloppement
            'frontend', 'backend', 'fullstack', 'responsive',
            'mvc', 'crud', 'rest', 'json', 'xml', 'debugging',
            'compilation', 'interpreteur', 'librairie', 'package'
        ];

        $contentLower = strtolower($content);

        // Compter les mots-cl√©s de programmation trouv√©s
        $programmingMatches = 0;
        foreach ($programmingKeywords as $keyword) {
            if (str_contains($contentLower, $keyword)) {
                $programmingMatches++;
            }
        }

        // V√©rifier les patterns de code EXPLICITES
        $codePatterns = [
            '/\{\s*[\w\s\(\)]+\s*\}/',          // Accolades avec contenu
            '/\$[a-zA-Z_]\w*/',                 // Variables PHP
            '/def\s+\w+\s*\(/',                 // Fonctions Python
            '/function\s+\w+\s*\(/',            // Fonctions JS
            '/class\s+\w+\s*[:\{]/',            // D√©clarations de classe
            '/import\s+\w+/',                   // Imports
            '/console\.log\s*\(/',              // Console.log
            '/\w+\(\s*\w*\s*\)/',              // Appels de fonction
            '/<\w+[^>]*>/',                     // Balises HTML
            '/\/\/.*|\/\*.*\*\//',             // Commentaires de code
        ];

        $codePatternMatches = 0;
        foreach ($codePatterns as $pattern) {
            if (preg_match($pattern, $content)) {
                $codePatternMatches++;
            }
        }

        // C'est de la programmation si :
        // - Au moins 2 mots-cl√©s de programmation OU
        // - Au moins 1 pattern de code clair
        $isProgramming = ($programmingMatches >= 2) || ($codePatternMatches >= 1);

        if ($isProgramming) {
            \Log::info('Contenu programmation d√©tect√©', [
                'programming_matches' => $programmingMatches,
                'code_pattern_matches' => $codePatternMatches,
                'content_preview' => Str::limit($content, 100)
            ]);
        }

        return $isProgramming;
    }

    /**
     * M√âTHODE CORRIG√âE : D√©tection math√©matique plus stricte
     * √âvite les conflits avec la programmation
     */
    protected function hasMathematicalContent(string $content): bool
    {
        // Mots-cl√©s STRICTEMENT math√©matiques (sans ambigu√Øt√© avec la programmation)
        $strictMathKeywords = [
            // Op√©rations math√©matiques SP√âCIFIQUES
            'calculer', 'calcul', 'r√©soudre', 'solution math√©matique',
            '√©quation', 'in√©quation', 'syst√®me d\'√©quations',

            // Domaines math√©matiques SP√âCIFIQUES
            'alg√®bre', 'g√©om√©trie', 'trigonom√©trie', 'logarithme',
            'd√©riv√©e', 'int√©grale', 'limite', 'fonction math√©matique',
            'matrice', 'vecteur', 'probabilit√©', 'statistique',
            'arithm√©tique', 'combinatoire', 'factorielle',

            // Termes math√©matiques SANS AMBIGU√èT√â
            'th√©or√®me', 'lemme', 'axiome', 'preuve math√©matique',
            'd√©monstration', 'conjecture',

            // Fonctions math√©matiques SP√âCIFIQUES
            'sinus', 'cosinus', 'tangente', 'exponentielle',
            'logarithme n√©p√©rien', 'arctangente', 'racine carr√©e',

            // Concepts num√©riques SP√âCIFIQUES
            'nombre premier', 'nombre entier', 'nombre r√©el', 'nombre complexe',
            'fraction', 'd√©cimal', 'pourcentage de',

            // Expressions math√©matiques CLAIRES
            'plus grand que', 'plus petit que', '√©gal √†',
            'somme de', 'produit de', 'quotient de',
            'racine de', 'puissance de', 'carr√© de', 'cube de'
        ];

        $contentLower = strtolower($content);

        // Compter les mots-cl√©s strictement math√©matiques
        $mathMatches = 0;
        foreach ($strictMathKeywords as $keyword) {
            if (str_contains($contentLower, $keyword)) {
                $mathMatches++;
            }
        }

        // V√©rifier les symboles math√©matiques SP√âCIFIQUES
        $mathSymbols = ['‚â†', '‚âà', '‚â§', '‚â•', '‚àö', '¬≤', '¬≥', '¬∞', 'œÄ', 'Œ£', '‚àë', '‚à´', '‚àû', '‚àÜ', 'Œ±', 'Œ≤', 'Œ≥', 'Œ∏'];
        $symbolMatches = 0;
        foreach ($mathSymbols as $symbol) {
            if (str_contains($content, $symbol)) {
                $symbolMatches++;
            }
        }

        // Patterns math√©matiques SP√âCIFIQUES (√©viter les conflits avec le code)
        $mathPatterns = [
            '/\d+\s*[\+\-\*\/\^]\s*\d+\s*=/',  // √âquations avec √©galit√©
            '/\d+\/\d+/',                       // Fractions
            '/\d+[eE][\+\-]?\d+/',             // Notation scientifique
            '/\(\s*\d+[\+\-\*\/]\d+\s*\)/',    // Expressions entre parenth√®ses
            '/x\s*[\+\-\*\/\^]\s*\d+/',        // Expressions alg√©briques
            '/\d+\s*x\s*[\+\-]/',              // Expressions lin√©aires
        ];

        $mathPatternMatches = 0;
        foreach ($mathPatterns as $pattern) {
            if (preg_match($pattern, $content)) {
                $mathPatternMatches++;
            }
        }

        // C'est des math√©matiques si :
        // - Au moins 1 mot-cl√© strictement math√©matique OU
        // - Au moins 1 symbole math√©matique OU
        // - Au moins 1 pattern math√©matique
        $isMathematical = ($mathMatches >= 1) || ($symbolMatches >= 1) || ($mathPatternMatches >= 1);

        if ($isMathematical) {
            \Log::info('Contenu math√©matique d√©tect√©', [
                'math_matches' => $mathMatches,
                'symbol_matches' => $symbolMatches,
                'math_pattern_matches' => $mathPatternMatches,
                'content_preview' => Str::limit($content, 100)
            ]);
        }

        return $isMathematical;
    }


    // ... (garder toutes les autres m√©thodes existantes inchang√©es)

    /**
     * V√©rifie si la question a une √©valuation compl√®te
     */
    public function hasCompleteEvaluation(): bool
    {
        return $this->evaluation && $this->evaluation->isComplete();
    }

    /**
     * Obtient les r√©ponses des IA organis√©es par mod√®le avec mapping correct
     */
    public function getResponsesByModel(): array
    {
        $responses = [];

        // Mapping des noms de mod√®les complets vers les cl√©s courtes
        $modelMapping = [
            'openai/gpt-4o' => 'gpt4',
            'deepseek/deepseek-r1' => 'deepseek',
            'qwen/qwen-2.5-72b-instruct' => 'qwen'
        ];

        foreach ($this->iaResponses as $response) {
            $modelKey = $modelMapping[$response->model_name] ?? $this->normalizeModelName($response->model_name);
            $responses[$modelKey] = $response;
        }

        return $responses;
    }

    /**
     * Normalise le nom du mod√®le pour correspondre aux cl√©s d'√©valuation
     */
    protected function normalizeModelName(string $modelName): string
    {
        return match($modelName) {
            'openai/gpt-4o' => 'gpt4',
            'deepseek/deepseek-r1' => 'deepseek',
            'qwen/qwen-2.5-72b-instruct' => 'qwen',
            default => strtolower(str_replace(['/', '-'], ['_', '_'], $modelName))
        };
    }

    /**
     * Obtient les statistiques des r√©ponses pour cette question
     */
    public function getResponsesStatsAttribute(): array
    {
        $responses = $this->iaResponses;

        return [
            'total' => $responses->count(),
            'average_tokens' => $responses->whereNotNull('token_usage')->avg('token_usage'),
            'average_response_time' => $responses->whereNotNull('response_time')->avg('response_time'),
            'models_used' => $responses->pluck('model_name')->unique()->values()->toArray()
        ];
    }

    /**
     * V√©rifie si toutes les r√©ponses IA sont disponibles
     */
    public function hasAllAIResponses(): bool
    {
        $expectedModels = ['gpt4', 'deepseek', 'qwen'];
        $actualModels = array_keys($this->getResponsesByModel());

        return count(array_intersect($expectedModels, $actualModels)) === 3;
    }

    /**
     * Obtient le temps de r√©ponse le plus rapide
     */
    public function getFastestResponseTimeAttribute(): ?float
    {
        return $this->iaResponses->whereNotNull('response_time')->min('response_time');
    }

    /**
     * Obtient le temps de r√©ponse le plus lent
     */
    public function getSlowestResponseTimeAttribute(): ?float
    {
        return $this->iaResponses->whereNotNull('response_time')->max('response_time');
    }

    /**
     * V√©rifie si la question n√©cessite une √©valuation automatique
     */
    public function needsAutomaticEvaluation(): bool
    {
        return $this->isEvaluableQuestion() &&
            $this->hasAllAIResponses() &&
            !$this->hasCompleteEvaluation();
    }

    /**
     * Obtient un r√©sum√© de la question pour les logs
     */
    public function getSummaryAttribute(): string
    {
        $content = Str::limit($this->content, 100);
        $type = $this->getEvaluationType();
        return "Question #{$this->id}: {$content} (Domain: {$this->domain?->name}, Type: {$type})";
    }

    /**
     * Obtient le statut d'√©valuation de la question
     */
    public function getEvaluationStatusAttribute(): string
    {
        if (!$this->isEvaluableQuestion()) {
            return 'not_evaluable';
        }

        if ($this->evaluation) {
            return $this->evaluation->isComplete() ? 'completed' : 'partial';
        }

        if ($this->hasAllAIResponses()) {
            return 'pending';
        }

        return 'waiting_responses';
    }

    /**
     * Scope pour les questions de programmation
     */
    public function scopeProgramming($query)
    {
        return $query->whereHas('domain', function($q) {
            $q->where(function($query) {
                $query->where('name', 'LIKE', '%programmation%')
                    ->orWhere('name', 'LIKE', '%code%')
                    ->orWhere('name', 'LIKE', '%d√©veloppement%')
                    ->orWhere('name', 'LIKE', '%programming%')
                    ->orWhere('name', 'LIKE', '%coding%')
                    ->orWhere('slug', 'LIKE', '%programming%')
                    ->orWhere('slug', 'LIKE', '%coding%');
            });
        });
    }

    /**
     * Scope pour les questions math√©matiques
     */
    public function scopeMathematics($query)
    {
        return $query->whereHas('domain', function($q) {
            $q->where(function($query) {
                $query->where('name', 'LIKE', '%math√©matiques%')
                    ->orWhere('name', 'LIKE', '%math%')
                    ->orWhere('name', 'LIKE', '%logique%')
                    ->orWhere('name', 'LIKE', '%mathematics%')
                    ->orWhere('name', 'LIKE', '%logic%')
                    ->orWhere('slug', 'LIKE', '%math%')
                    ->orWhere('slug', 'LIKE', '%logic%');
            });
        });
    }

    /**
     * Scope pour les questions √©valuables (programmation OU math√©matiques)
     */
    public function scopeEvaluable($query)
    {
        return $query->where(function($q) {
            $q->whereHas('domain', function($query) {
                $query->where(function($subQuery) {
                    // Programmation
                    $subQuery->where('name', 'LIKE', '%programmation%')
                        ->orWhere('name', 'LIKE', '%code%')
                        ->orWhere('name', 'LIKE', '%d√©veloppement%')
                        ->orWhere('name', 'LIKE', '%programming%')
                        ->orWhere('name', 'LIKE', '%coding%')
                        ->orWhere('slug', 'LIKE', '%programming%')
                        ->orWhere('slug', 'LIKE', '%coding%')
                        // Math√©matiques
                        ->orWhere('name', 'LIKE', '%math√©matiques%')
                        ->orWhere('name', 'LIKE', '%math%')
                        ->orWhere('name', 'LIKE', '%logique%')
                        ->orWhere('name', 'LIKE', '%mathematics%')
                        ->orWhere('name', 'LIKE', '%logic%')
                        ->orWhere('slug', 'LIKE', '%math%')
                        ->orWhere('slug', 'LIKE', '%logic%');
                });
            });
        });
    }

    /**
     * Scope pour les questions avec toutes les r√©ponses IA
     */
    public function scopeWithAllResponses($query)
    {
        return $query->whereHas('iaResponses', function($q) {
            $q->whereIn('model_name', [
                'openai/gpt-4o',
                'deepseek/deepseek-r1',
                'qwen/qwen-2.5-72b-instruct'
            ]);
        }, '=', 3);
    }

    /**
     * Scope pour les questions sans √©valuation
     */
    public function scopeWithoutEvaluation($query)
    {
        return $query->doesntHave('evaluation');
    }

    /**
     * Scope pour les questions qui n√©cessitent une √©valuation
     */
    public function scopeNeedsEvaluation($query)
    {
        return $query->evaluable()
            ->withAllResponses()
            ->withoutEvaluation();
    }

    /**
     * Scope pour les questions par type d'√©valuation
     */
    public function scopeByEvaluationType($query, string $type)
    {
        switch ($type) {
            case 'mathematics':
                return $query->mathematics();
            case 'programming':
                return $query->programming();
            case 'evaluable':
                return $query->evaluable();
            default:
                return $query;
        }
    }

    /**
     * Obtient les tags associ√©s √† la question
     */
    /**
     * üîß MISE √Ä JOUR : Obtient les tags associ√©s √† la question AVEC TRADUCTION
     */
    public function getTagsAttribute(): array
    {
        $tags = [];

        // Tag du domaine
        if ($this->domain) {
            $tags[] = $this->domain->name;
        }

        // Tags selon le type
        if ($this->isTranslationQuestion()) {
            $tags[] = 'Traduction';
            $tags[] = '√âvaluable';
        } elseif ($this->isMathematicalQuestion()) {
            $tags[] = 'Math√©matiques';
            $tags[] = '√âvaluable';
        } elseif ($this->isProgrammingQuestion()) {
            $tags[] = 'Programmation';
            $tags[] = '√âvaluable';
        } else {
            $tags[] = 'Question g√©n√©rale';
        }

        // Tag d'√©valuation
        if ($this->evaluation) {
            $tags[] = '√âvalu√©e';
        } elseif ($this->isEvaluableQuestion() && $this->hasAllAIResponses()) {
            $tags[] = 'Pr√™te pour √©valuation';
        }

        // Tag selon le nombre de r√©ponses
        $responseCount = $this->iaResponses->count();
        if ($responseCount >= 3) {
            $tags[] = 'Compl√®te';
        } elseif ($responseCount > 0) {
            $tags[] = 'Partielle';
        } else {
            $tags[] = 'Sans r√©ponse';
        }

        return array_unique($tags);
    }


    /**
     * Obtient une description du type de question
     */
    public function getTypeDescriptionAttribute(): string
    {
        if ($this->isTranslationQuestion()) {
            return 'Question de traduction linguistique';
        } elseif ($this->isMathematicalQuestion()) {
            return 'Question de math√©matiques ou logique';
        } elseif ($this->isProgrammingQuestion()) {
            return 'Question de programmation';
        } else {
            return 'Question g√©n√©rale';
        }
    }

    public function scopeTranslation($query)
    {
        return $query->whereHas('domain', function($q) {
            $q->where(function($query) {
                $query->where('name', 'LIKE', '%traduction%')
                    ->orWhere('name', 'LIKE', '%translation%')
                    ->orWhere('name', 'LIKE', '%translate%')
                    ->orWhere('name', 'LIKE', '%langues%')
                    ->orWhere('name', 'LIKE', '%linguistics%')
                    ->orWhere('slug', 'LIKE', '%translation%')
                    ->orWhere('slug', 'LIKE', '%translate%');
            });
        });
    }


    protected function hasTranslationContent(string $content): bool
    {
        $translationKeywords = [
            // Mots-cl√©s fran√ßais EXPLICITES
            'traduire', 'traduisez', 'traduction', 'traduis',
            'en fran√ßais', 'en anglais', 'en espagnol', 'en allemand',
            'vers le fran√ßais', 'vers l\'anglais',

            // Mots-cl√©s anglais EXPLICITES
            'translate', 'translation', 'translate to', 'translate into',
            'into french', 'into english', 'into spanish',
            'from french', 'from english',

            // Patterns de langues SP√âCIFIQUES
            'fran√ßais-anglais', 'anglais-fran√ßais',
            'french-english', 'english-french',
            'spanish-english', 'german-french',

            // Expressions courantes de traduction
            'comment dit-on', 'comment dire en',
            'what does it mean in', 'how do you say',
            'que signifie en', 'que veut dire en'
        ];

        $contentLower = strtolower($content);

        // Compter les mots-cl√©s de traduction trouv√©s
        $translationMatches = 0;
        foreach ($translationKeywords as $keyword) {
            if (str_contains($contentLower, $keyword)) {
                $translationMatches++;
            }
        }

        // V√©rifier les patterns de traduction EXPLICITES
        $translationPatterns = [
            '/traduire?\s*[:]\s*.+/i',                  // "Traduire: Hello"
            '/translate\s+to\s+\w+\s*[:]\s*.+/i',      // "Translate to French: Hello"
            '/en\s+\w+\s*[:]\s*.+/i',                  // "En fran√ßais: Hello"
            '/\w+\s+to\s+\w+\s*[:]\s*.+/i',           // "English to French: Hello"
            '/comment\s+dit-on\s*.+/i',                // "Comment dit-on..."
            '/que\s+signifie\s*.+/i',                  // "Que signifie..."
            '/how\s+do\s+you\s+say\s*.+/i',           // "How do you say..."
            '/what\s+does\s*.+\s+mean\s+in\s+\w+/i',  // "What does X mean in French"
        ];

        $translationPatternMatches = 0;
        foreach ($translationPatterns as $pattern) {
            if (preg_match($pattern, $content)) {
                $translationPatternMatches++;
            }
        }

        // C'est de la traduction si :
        // - Au moins 1 mot-cl√© de traduction ET 1 pattern OU
        // - Au moins 2 mots-cl√©s de traduction
        $isTranslation = (($translationMatches >= 1) && ($translationPatternMatches >= 1)) ||
            ($translationMatches >= 2);

        if ($isTranslation) {
            \Log::info('Contenu traduction d√©tect√©', [
                'translation_matches' => $translationMatches,
                'pattern_matches' => $translationPatternMatches,
                'content_preview' => Str::limit($content, 100)
            ]);
        }

        return $isTranslation;
    }




    public function forceEvaluationTypeByDomain(): string
    {
        if (!$this->domain) {
            return 'none';
        }

        $domainName = strtolower($this->domain->name);
        $domainSlug = strtolower($this->domain->slug ?? '');

        // üåê Forcer traduction si domaine explicite (PRIORIT√â 1)
        $translationDomains = ['traduction', 'translation', 'translate', 'langues', 'linguistics'];
        foreach ($translationDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                return 'translation';
            }
        }

        // Forcer programmation si domaine explicite (PRIORIT√â 2)
        $programmingDomains = ['programmation', 'programming', 'code', 'd√©veloppement', 'web'];
        foreach ($programmingDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                return 'programming';
            }
        }

        // Forcer math√©matiques si domaine explicite (PRIORIT√â 3)
        $mathDomains = ['math√©matiques', 'math', 'logique', 'calcul'];
        foreach ($mathDomains as $keyword) {
            if (str_contains($domainName, $keyword) || str_contains($domainSlug, $keyword)) {
                return 'mathematics';
            }
        }

        return 'none';
    }


    public function testDeepLWithQuestionText()
    {
        try {
            $deepL = app(\App\Services\DeepLService::class);

            // Extraire le texte √† traduire de la question
            $content = $this->content;

            // Patterns pour extraire le texte source
            $patterns = [
                '/translate\s+to\s+\w+\s*:\s*(.+)/i',
                '/traduire?\s*[:]\s*(.+)/i',
                '/en\s+\w+\s*[:]\s*(.+)/i'
            ];

            $sourceText = null;
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $sourceText = trim($matches[1]);
                    break;
                }
            }

            if (!$sourceText) {
                $sourceText = $content; // Fallback
            }

            // Test avec les m√™mes param√®tres que l'√©valuation
            return $deepL->translate($sourceText, 'FR', 'auto');

        } catch (\Exception $e) {
            return [
                'status' => 'error',
                'error' => $e->getMessage()
            ];
        }
    }


}
